(window.webpackJsonp=window.webpackJsonp||[]).push([[156],{362:function(e,t,n){"use strict";n.r(t);var o=n(6),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"debugger"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#debugger"}},[e._v("#")]),e._v(" debugger")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("resume/continue")])]),e._v(" "),n("li",[n("p",[e._v("step into：单步执行，遇到子函数就进入并且继续单步执行（简而言之，进入子函数）；")])]),e._v(" "),n("li",[n("p",[e._v("step over：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。有一点,经过我们简单的调试,在不存在子函数的情况下是和step into效果一样的（简而言之，越过子函数，但子函数会执行）。")])]),e._v(" "),n("li",[n("p",[e._v("step out：当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。")])])]),e._v(" "),n("p",[e._v("step")]),e._v(" "),n("p",[e._v("Pause/Resume script execution：暂停/恢复脚本执行（程序执行到下一断点停止）。\nStep over next function call：执行到下一步的函数调用（跳到下一行）。\nStep into next function call：进入当前函数。\nStep out of current function：跳出当前执行函数。\nDeactive/Active all breakpoints：关闭/开启所有断点（不会取消）。\nPause on exceptions：异常情况自动断点设置。")]),e._v(" "),n("p",[e._v("Watch：Watch表达式\nCall Stack: 栈中变量的调用，这里是递归调用，肯定是在内存栈部分调用。\nScope：当前作用域变量观察。\nBreakPoints：当前断点变量观察。\nXHR BreakPoints：面向Ajax，专为异步而生的断点调试功能。\nDOM BreakPoints：主要包括下列DOM断点，注册方式见下图\n当节点属性发生变化时断点（Break on attributes modifications）\n当节点内部子节点变化时断点（Break on subtree modifications）\n当节点被移除时断点（Break on node removal）")]),e._v(" "),n("p",[e._v("Global Listeners：全局事件监听\nEvent Listener Breakpoints：事件监听器断点，列出了所有页面及脚本事件，包括：鼠标、键盘、动画、定时器、XHR等等。")]),e._v(" "),n("p",[e._v("Pause on exception 在捕获到未知错误时暂停运行，但是如果代码加了 "),n("code",[e._v("try...catch")]),e._v("，则不能定位到异常的位置。")]),e._v(" "),n("p",[e._v("Pause on caught exceptions 捕获到错误时暂停，包括 "),n("code",[e._v("try.catch")]),e._v(" 里面的异常也可以定位到具体位置。")])])}),[],!1,null,null,null);t.default=a.exports}}]);