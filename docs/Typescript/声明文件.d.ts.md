# 声明文件 `*.d.ts`

[toc]

## 语法列表

- `declare var/let/const`  声明全局变量/常量
- `declare function` 声明全局函数
- `declare class` 声明全局类
- `declare enum` 声明全局枚举类型
- `declare namespace` 声明全局对象
- `interface` 声明全局接口
- `type` 声明全局类型别名
- `export` 导出变量
- `export namespace` 导出（含有子属性的）对象
- `export default` ES6 默认导出
- `export =` commonjs 导出模块
- `export as namespace` UMD 库声明全局变量
- `declare global` 扩展全局变量
- `declare module` 扩展模块
- `/// <reference />` 三斜线指令

## 声明文件是什么

引入第三方库时，如果该库没有提供类型声明，TypeScript 则不知道该库是什么类型，有什么东西？

- 声明文件必需以 `.d.ts` 为后缀扩展名，比如： `jQuery.d.ts`。
- 声明文件仅仅会用于编译时的检查，在编译结果中会被删除，完全消失。
- 第三方库如果不是用 TypeScript 编写，则它的声明通常发布到由 DefinitelyTyped 统一管理的 `@types` 中。

安装第三方库声明文件：

```bash
npm install @types/jquery --save-dev
```

搜索第三方库声明文件： `https://www.typescriptlang.org/dt/search?search=`

当一个第三方库没有提供声明文件时，就需要自己书写声明文件了。

## 声明文件的使用

声明文件有两种使用方法：

- 将声明文件和源码放在一起
- 将声明文件发布到 `@types` 下

### 声明文件和源码放在一起

如果声明文件是通过 tsc 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。

如果是手动写的声明文件，那么需要满足以下任一一项条件，才能被正确的识别：

- 给 package.json 中的 `types` 或 `typings` 字段指定类型声明文件的路径。
- 声明文件放在项目根目录下，命名为 `index.d.ts`
- 与入口文件（package.json 中的 main 字段指定的入口文件）一起，编写一个同名 `.d.ts` 文件

TypeScript 查找声明文件顺序：

- 先查找 package.json 的 `types` 或 `typings` 字段，如果没有
- 再查找项目根目录下的 `index.d.ts` 文件，如果没有
- 再查找入口文件的同名 `.d.ts` 文件，如果没有
- TypeScript 则认为没有提供声明文件。

#### 设置 package.json 的 `types` 或 `typings` 字段

`typings` 与 `types` 一样，只是不同的两种写法，任选一个即可。

```json
{
  "name": "foo",
  "version": "1.0.0",
  "main": "src/index.js",
  "types": "@types/index.d.ts",
}
```

## 编写声明文件

声明语句中只能定义类型，禁止在声明语句中定义具体的实现。

在不同的场景下，声明文件的内容和使用方式会有所区别。

库的使用场景主要有以下几种：

- 全局变量：通过 `<script>` 标签引入第三方库，注入全局变量
- npm 包：通过 `import foo from 'foo'` 导入，符合 ES6 模块规范
- UMD 库：既可以通过 `<script>` 标签引入，又可以通过 import 导入
- 直接扩展全局变量：通过 `<script>` 标签引入后，改变一个全局变量的结构
- 在 npm 包或 UMD 库中扩展全局变量：引用 npm 包或 UMD 库后，改变一个全局变量的结构
- 模块插件：通过 `<script>` 或 import 导入后，改变另一个模块的结构

### 声明全局变量

场景：假如使用 `<script>` 引入了一个库，这个库会暴露一个全局变量出来，在项目应用代码中就需要直接使用这个变量，但是 TypeScript 不知道这是一个全局变量，根本不知道它是否存在，也不知道它是什么东西，直接使用它就会报错。这时候就需要我们声明一个全局变量来告诉 TypeScript 这是一个在全局存在的变量，它是什么类型。

声明全局变量时，应确保在运行时会有这个全局变量存在，否则项目中使用了此全局变量，编译阶段因为有声明全局变量而不会报错，但运行时没有此变量存在时，会报错导致程序停止运行。

可以使用的全局声明语法：

- `declare var/let/const`  声明全局变量/常量
- `declare function` 声明全局函数
- `declare class` 声明全局类
- `declare enum` 声明全局枚举类型
- `declare namespace` 声明全局对象
- `interface` 声明全局接口
- `type` 声明全局类型别名

#### `declare var/let/const` 声明全局变量或常量

```ts
// index.d.ts

declare var a: string
declare let b: boolean
declare const c: string
declare const fn: (a: string) => string
// 在声明文件中定义具体的实现会报错
// 编译报错 Initializers are not allowed in ambient contexts.
declare const d: number = 1
```

不同于应用中的代码，使用 `declare var` 和 `declare let` 在声明文件中没有区别，都是声明一个全局变量。

使用 `declare const` 则表示声明一个全局常量，不可被更改。

一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 `const` 而不是 `var` 或 `let`。

#### `declare function` 声明全局函数

```ts
declare function fn(): void

// 函数重载
declare function fn(a: string): string;
declare function fn(b: () => number): number;
```

和应用代码一样，可以用函数声明或者函数表达式：

```ts
// 函数声明
declare function fn(a: string): string

// 函数表达式
declare const fn: (a: string) => string
```

#### `declare class` 声明全局 class 类

```ts
declare class Person {
  public name: string
  constructor(name: string)
  sayHi(): string
}
```

错误示范：

```ts
// 错误示范

declare class Person {
  name: string
  // 编译报错：此处 public 实际还包含一种具体的实现（赋值），声明中禁止实现
  // A parameter property is only allowed in a constructor implementation.
  constructor(public name: string)
  sayHi(): string
}
```

#### `declare enum` 声明全局枚举

```ts
declare enum Directions {
  Up,
  Down,
  Left,
  Right
}
```

#### `declare namespace` 声明全局对象

`namespace` 是 ts 早期时为了解决应用代码中的模块化而创造的关键字，中文称为命名空间。

由于历史遗留原因，在早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 `module` 关键字表示内部模块。但由于后来 ES6 也使用了 `module` 关键字，ts 为了兼容 ES6，使用 `namespace` 替代了自己的 `module`，更名为命名空间。

随着 ES6 的广泛应用，现在已经不建议再在普通应用代码中使用 ts 中的 `namespace`，而推荐使用 ES6 的模块化方案了，故我们不再需要学习 namespace 在应用代码中的使用了。

但是，在声明文件中，`declare namespace` 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。

`declare namespace` 语句内部，不需要再使用 `declare` 来声明属性或方法，而是直接声明，可以在其中使用所有的声明方式，包括嵌套 `namespace` 来表示更深的对象：

```ts
declare namespace person {
  const name: string
  const age: number
  function intro(): string
  namespace son {
    const name: string
    function intro(): string
  }
}
```

以上代码表示，在全局有一个对象名字要做 `person`，对象中有 `string` 类型的 `name` 属性和 `number` 类型的 `age` 属性，还有一个方法 `intro`，不接受参数，运行后返回一个字符串。

以上代码中的子对象也可以不使用嵌套声明：

```ts
declare namespace person {
  const name: string
  const age: number
}

declare namespace person.son {
  const name: string
  function intro(): string
}
```

错误示范：

```ts
// 错误示范

declare namespace person {
  // 编译报错：此处，已经处于一个 declare 环境上下文中，不应再使用 declare
  // A 'declare' modifier cannot be used in an already ambient context.
  declare const name: string
}
```

#### `interface | type` 声明全局接口和类型别名

除了可以暴露声明的全局变量，还可以暴露声明的接口(interface)和类型(type)到全局中。

在类型声明文件中，可以直接使用 `interface` 或 `type` 来声明一个全局的接口或类型，将它暴露到全局去使用。

`type` 使用方式和 `interface` 一样，以下以 `interface` 举例：

```ts
// index.d.ts

interface student {
  name: string
  age?: number
  intro?(): string
}

declare const tom: student
```

上面这个声明文件中，声明了一个 `interface` 给全局变量 `tom` 使用，同时 `student` 接口会暴露到全局中去，全局任何地方都可以使用它。

在某个应用代码文件中使用这个接口：

```ts
// xxx.ts

const jerry: student = {
  name: 'tom'
}
```

#### 防止命名冲突

像之前那个声明文件中那样直接暴露 `interface` 或 `type` 到全局中，一旦项目变大一点，很容易产生命名冲突的问题。

应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 `namespace` 下

声明文件：

```ts
// index.d.ts

// 声明一个全局命名空间
declare namespace person {

  // 接口放在命名空间下
  interface student {
    name: string
    age?: number
    intro?(): string
  }

  // 在命名空间下使用接口
  const jerry: student
}

// 在命名空间外部使用命名空间内的接口
declare const tom: person.student
```

在应用代码中复用：

```ts
// xxx.ts

// 在应用代码中使用时，则需要从命名空间下去取这个接口
const bob: person.student = {
  name: 'bob'
}
```

#### 声明合并

比如一个变量既是函数，又是一个对象，则可以多次声明，它们会被自动合并。

```ts
declare function person(): void
declare namespace person {
  const name: string
}
```

之前讲到的函数重载其实就是一种声明合并：

```ts
// 函数重载，这也是一种声明合并
declare function fn(a: string): string;
declare function fn(b: () => number): number;
```

函数，命名空间，类，接口可以同时出现相同的名字：

```ts

// 声明一个叫做 person 的 函数
declare function person(): void

// 声明一个叫做 person 的 命名空间
declare namespace person {
  const name: string
}

// 声明一个叫做 person 的 类
declare class person {
  constructor(name: string)
}

// 声明一个叫做 person 的 接口
declare interface person {
  age: number
}
```

`class` 和 `interface` 被合并后，`class` 创建的实例就是 `interface` 的类型。

```ts
// index.d.ts

declare class person {
  name: string
}

declare interface person {
  age: number
}

// index.ts
const tom: person = new person()
```

`function`, `interface`, `namespace` 重复声明一个变量，都可以被合并，但同时声明两个同名 class 不会被合并，会报错：

```ts
// 重复声明 interface ，会被合并
declare interface person {
  name: string
}
declare interface person {
  age: number
}

// 重复声明 namespace ，会被合并
declare namespace person1 {
  const name: string
}
declare namespace person1 {
  const age: number
}

// 报错：Duplicate identifier 'person2'.
declare class person2 {
  name: string
}
declare class person2 {
  age: number
}
```

合并的同名属性类型必须是保持一致，否则会报错：

```ts

declare interface person {
  name: string
}
declare interface person {
  // 编译报错：要合并的属性类型不一致
  // Subsequent property declarations must have the same type.
  // Property 'name' must be of type 'string', but here has type 'number'.
  name: number
}
```

声明合并还可以扩展已存在的类型：

```ts
// index.d.ts

// 扩展 String 类型，在应用代码中访问时 TypeScript 才不会在编译阶段报错。
interface String {
  myFunc(): string;
}
```

```ts
// indes.ts

'hello'.myFunc()
```

注意：声明文件中只是告诉 TypeScript 在 String 类的原型上还有一个 `myFunc` 方法，但实际上还需要自己或是第三方库去添加一个真正可被调用的方法到 `String` 的原型上，否则在运行时会因为没有这个方法而报错。

### 声明文件中的依赖

一个声明文件有时会依赖另一个声明文件中的类型，所以需要引入另一个文件。

在声明文件中引入其它声明文件有两种方式：

- `import` 通过 `import` 语法引入
- `/// <reference />` 通过三斜线指令引入

#### import

`import` 用于在模块声明文件中引入另一个模块声明文件：

```ts
// moduleA.d.ts

export interface person {
  name: string
  age: number
}

declare function aFunc (person: person): void
```

```ts
// moduleB.d.ts

import { person } from './a'

declare function bFunc(person: person): void
```

注意，引用和被引用的都应该是 **模块** 声明文件，`import` 方式无法用于全局声明文件之中，无论是引用还是被引用。

因为在全局声明文件中不能出现 `import`,`export` 等关键字，一旦出现，这个文件就会被视为模块，而不再是全局声明。

所以上面的 `moduleA.d.ts` 和 `moduleB.d.ts` 都会被视为模块声明文件，这两个文件中声明的变量都无法在全局直接访问：

```ts
// index.ts

aFunc() // 编译报错：Cannot find name 'aFunc'.
bFunc() // 编译报错：Cannot find name 'bFunc'.
```

如果要在一个全局声明文件中引用另一个声明文件，则需要用到三斜线指令（`/// <reference />`）：

#### 三斜线指令（/// `<reference />`）

三斜线指令必须放在文件的最顶端，前面只允许出现注释。

`<reference />` 支持两种引入属性：`types` 和 `path`

- `types` 引入一个类型库，比如依赖 `@types/foo` 时： `<reference types="foo"/>`
- `path` 引入一个文件，比如： `<reference path="./moduleA.d.ts"/>`

当且仅当在书写一个全局变量的声明文件，且需要依赖一个全局变量的声明文件或库时，才需要用到 `<reference />` 来替代 `import`，其它情况使用 `import` 即可。

错误用法：

```ts
// moduleA.d.ts

export interface person {
  name: string
  age: number
}

interface person2 {
  name: string
}

declare function aFunc (person: person): void

```

```ts
// index.d.ts

/// <reference path="./moduleA.d.ts" />

// 编译报错，访问不了模块声明中的 person
declare function indexFunc (person: person): void
// 编译报错，访问不了模块声明中的 person2
declare const indexFunc2: person2
```

上例的 `moduleA.d.ts` 中使用了 `export` 关键字，所以 `moduleA.d.ts`被视为了一个模块声明文件，所以在 `index.d.ts` 中通过 `<reference />` 引用 `moduleA.d.ts` 无法访问其中的任何一条声明，不管这条声明有没有使用 `export`。

正确用法：

```ts
// moduleB.d.ts

interface person {
  name: string
  age: number
}

declare function bFunc (person: person): void
```

```ts
/// <reference path="./moduleB.d.ts" />

declare function indexFunc (person: person): void

```

总结：

- 使用 `export` 导出的文件只能使用 `import` 引入，无法通过 `<reference />` 引入。

- 普通全局声明文件只能使用 `<reference />` 引入，无法通过 `import` 引入。

##### 拆分声明文件

当全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。

```ts
// index.d.ts

/// <reference path="moduleA.d.ts" />
/// <reference path="moduleB.d.ts" />
/// <reference path="moduleC.d.ts" />
/// <reference path="moduleD.d.ts" />
```
