
# 数据类型

对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：

## 字符串类型

MySQL 中的一些特殊符号不能直接输入使用，需要将其进行转义，在字符前加上反斜线 `\` ，这些特殊字符成为转义字符。

转义字符有单引号(`'`)、双引号(`"`)、反斜线(`\`)，回车符(`\r`)，换行符(`\n`)，制表符(`\tab`)，退格符(`\b`) 等

在 Windows 平台下，MySQL 是不区分大小写的，因此字符串比较函数也不区分大小写。如果想执行区分大小写的比较，可以在字符串前面添加 `BINARY` 关键字。例如，默认情况下，'a' = 'A' 的返回结果为 1，如果使用 `BINARY` 关键字，即 `BINARY 'a' = 'A'` ，则结果为 `0` 。在区分大小写的情况下，'a' 与 'A' 并不相同。

类型 | 说明
-- | --
`CHAR(n)` | 定长字符串，占 n 字节，n 取值为 `1 ~ 255` ，n 必须在表创建时指定，否则默认为 `1`，长度不够时右侧补充空格（查询时会自动去除空格）。
`VARCHAR(n)` | 变长字符串，占 `实际字符数 + 1` 字节，n 取值为 `0 ~ 65535`，utf8 最大为 `21844` 个字符，gbk 最大为 `32766` 个字符，latin1 最大为 `65532` 个字符
`TINYTEXT` | 文本，占 `实际字符数 + 1` 字节，最大长度为 255(2**8 - 1) 个字符
`TEXT` | 文本，占 `实际字符数 + 2` 字节，最大长度为 65535(2**16 - 1) 个字符
`MEDIUMTEXT` | 文本，占 `实际字符数 + 3` 字节，最大长度为 16777215(2**24 - 1) 个字符
`LONGTEXT` | 文本，占 `实际字符数 + 4` 字节，最大长度为 4294967295(2**32 - 1) 个字符
`ENUM` | 枚举类型，占 1 或 2 字节，取决于枚举值数目(最大 `65535`)
`SET` | 一个设置，字符串对象可以有 0 或 多个 SET 成员，占 `1 | 2 | 3 | 4 | 8` 个字节，取决于集合成员的数量（最多 64 个成员）

不管使用何种形式的串数据类型，串值都必须括在引号内（通常单引号更好）。

电话号码，邮政编码等纯数字类型的值，虽然是纯数字组成，但他们的值不会用于数学计算，因此用字符串更合适，而不是用数值类型。

既然变长数据类型很灵活，为什么还要使用定长数据类型？回答是因为性能。MySQL处理定长列远比处理变长列快得多。此外，MySQL不允许对变长列（或一个列的可变部分）进行索引。这也会极大地影响性能。

CHAR 和 VARCHAR 存储区别（使用 `x` 表示空格）：

插入值 | CHAR(4) | VARCHAR(4)
| -- | -- | -- |
`` | `xxxx`, 4 字节 | ``, 1 字节
`ab` | `abxx`, 4 字节 | `ab`, 3 字节
`abc` | `abcx`, 4 字节 | `abc`, 4 字节
`abcd` | `abcd`, 4 字节 | `abcd`, 5字节
`abcdef` | `abcd`, 4 字节，严格模式报错 | `abcd`, 5字节，严格模式报错

存储引擎对于选择 `CHAR` 和 `VARCHAR` 的影响:

- 对于 MyISAM 存储引擎:最好使用固定长度的数据列代替可变长度的数据列。这样可以
使整个表静态化，从而使数据检索更快，用空间换时间。
- 对于 InnoDB 存储引擎:使用可变长度的数据列，因为 InnoDB 数据表的存储格式不分固定长度和可变长度，因此使用 CHAR 不一定比使用 VARCHAR 更好，但由于 VARCHAR是按照实际的长度存储的，比较节省空间，所以对磁盘I/O 和数据存储总量比较好。

### ENUM 类型

ENUM 是一个字符串对象，其值为表创建时在列规定中枚举的列值之一。

语法：

```sql
CREATE TABLE <表名> (
  <列名> ENUM('<值1>', '<值2>', ..., '<值n>')
);
```

枚举类型的列值只能在指定的若干个值之中取一个值，或者是这个值对应的索引值（从第一个值为 `1` 开始）。每个成员的尾部空格会被移除。

比如性别一列使用 `gender ENUM('男', '女', '保密')` 定义后，插入或修改数据时，只能插入 `'男', 1, '女', 2, '保密', 3` 其中之一，允许为 `NULL` 时还可以插入 `NULL` 。

ENUM 类型的列在插入时及时不指定值，也始终会有一个默认值，允许为 `NULL` 时，默认值为 `NULL`，设为 `NOT NULL` 时，默认为枚举集合的第一个元素。

### SET 类型

SET 类型和 ENUM 类似，定义的方式是一样的，区别是，ENUM 列只能插入枚举值成员的其中一个值， SET 列可以插入集合中的多个值的联合。

如果插入的列值中有重复值，会自动删除重复的值，插入值的顺序不重要，会自动按照 SET 定义值的顺序来存储，插入了不在 SET 集合成员中的值时，会被阻止并报错。

语法：

```sql
CREATE TABLE <表名> (
  <列名> SET('<值1>', '<值2>', ..., '<值n>')
);
```

示例：

```sql
CREATE TABLE test (
  col SET('a', 'b', 'c', 'd')
);
```

插入数据

```sql
INSERT INTO test values('a'), ( 'a,b,a'), ('c,a,d');
```

上例插入数据后，查询结果，第一行为 `a`，第二行为 `a,b`，第三行为 `a,c,d` 。可见第二行被去除了重复值，第三行被自动按定义顺序排列。

再插入一行包含集合成员之外的值：

```sql
INSERT INTO test values ('a,x,b,y');
```

上例插入值中的包含集合成员之外的值 `x` 和 `y`, 所以插入失败，抛出错误。

### ENUM 和 SET

在多个值中，只能选择一个值，比如性别，使用 ENUM

在多个值中，选择多个值，比如兴趣爱好，使用 SET

## 数值类型

有符号值，可以存储 `-n ~ n` 范围内的值，使用 `UNSIGNED` 表示使用无符号值后，只有正值，范围为 `0 ~ 2n`。

注意，在 MySQL 8 中，已经不推荐为字段指定显示宽度，后文提到的显示宽度仅做介绍，不建议再使用。

类型 | 说明 | 占字节 | 有符号取值范围 | 无符号取值范围
| -- | -- | -- | -- | -- |
`TINYINT(4)` | 整数 | 1 | `-128 ~ 127` | `0 ~ 255` 2<sup>8<sup>
`SMALLINT(6)` | 整数 |  2 | `-32768 ~ 32767` |`0 ~ 65535` 2<sup>16<sup>
`MEDIUMINT(9)` | 整数 | 3 | `-8388608 ~ 8388607` | `0 ~ 16777215` 2<sup>24<sup>
`INT(11) （或INTEGER）` | 整数 | 4 | `-2147483648 ~ 2147483647` | `0 ~ 4294967295` 2<sup>32<sup>
`BIGINT(20)` | 整数 |  8 | `-9223372036854775808 ~ 9223372036854775807` | `0 ~ 18446744073709551615` 2<sup>64<sup>
`BOOLEAN（或BOOL）` | 布尔值 | | `0 | 1`
`DECIMAL(m, d)（或DEC）` | 定点数类型 | m + 2 | m 表示精度（总位数），d 表示标度（小数位数），默认 `DECIMAL(10, 0)`
`FLOAT` | 单精度浮点值 | 4 | `-3.402823466E+38 ~ -1.175494351E-38`, `0`, `1.175494351E-38 ~ 3.402823466E+38` | `0`, `1.175494351E-38 ~ 3.402823466E+38`
`DOUBLE` | 双精度浮点值 | 8 | `-1.7976931348623157E+308 ~ -2.2250738585072014E-308`, `0`, `2.2250738585072014E-308 ~ 1.7976931348623157E+308` | `0`, `2.2250738585072014E-308 ~ 1.7976931348623157E+308`
`REAL` | `DOUBLE` 或 `FLOAT` | - | 默认就是 `DOUBLE` ，除非手动设置了 SQL 模式 `SET sql_mode = "REAL_AS FLOAT"` | - |
`BIT(m)` | 位类型(二进制) | - | m 指定二进制字符串长度，m 取值范围为 `[1, 64]`, 默认为 `1` 。在 MySQL 5 之前，BIT在功能上等价于 `TINYINT`

整数类型括号中的数字表示显示的宽度，宽度包含1个符号位，所以实际数字的数量为显示宽度减去 `1` ，当不指定显示宽度时，上表的括号中就是整数的默认显示宽度。

显示宽度和数据类型取值范围无关，显示宽度仅用于指明 MySQL 最大可能显示的数字个数，并不会限制取值范围和占用空间大小。数字字符不够时会由空格填充，字符数超过时依然可以正常插入，且能够显示出来，比如对 `INT(4)` 类型的字段插入值 `19999` ，查询时显示地就是 5 位数的值。

如果想在数字字符未达到显示宽度时，前面用 0 来填充，比如 `INT(8)` 的值为 `1234` 时，显示为 `00001234` ，可以在字段定义时指定 `INT(8) ZEROFILL` 表示补 0 。

```sql
CREATE TABLE <表名> (
  int1 INT, # 未指定显示宽度，取默认值 11
  int2 INT(8), # 仅指定显示宽度时，实际显示效果和未指定时没有区别
  int3 INT(8) ZEROFILL, # 指定显示宽度和 `ZEROFILL` 时，才会在数字不够时，在前面补 0
  int3 INT(8) ZEROFILL UNSIGNED # ZEROFILL 默认会添加 UNSIGNED ，但也可以手动显式添加
);
```

需要注意的是，指定了 `ZEROFILL` 的字段，会自动添加 `UNSIGNED` 表示该字段无符号，也就是不能为负数。

浮点数指定 `UNSIGNED` 不能增大正数的存储范围，仅仅是不能存储负数了而已。比如 `FLOAT(5, 2)` 范围为 `-999.99 ~ 999.99` ，`FLOAT(5, 2) UNSIGNED` 范围为 `0 ~ 999.99` 。

浮点类型在计算时存在精度丢失问题，单精度比双精度丢失的精度更多，所以使用浮点数做计算和比较时，需要注意精度丢失导致的意外的结果。

定点数类型是高精度的，不会导致精度丢失，需要高精度的小数时，应尽可能使用 `DECIMAL` 。

浮点数类型和定点数类型，如果值的小数部分超出指定的精度范围，则会将小数部分四舍五入，整数部分超出范围则会报错。

在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候(如货币、科学数据等)，使用 `DECIMAL` 的类型比较好，另外两个浮点数进行减法和比较运算时容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。

上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如， `REAL` 又可以写成 `FLOAT(24)` 。各数据库厂商还会支持特定的数据类型，例如 `JSON` 。

## 日期类型

类型 | 说明 | 字节 | 格式 | 最小值 | 最大值
| -- | -- | -- | -- | -- | -- |
`DATE` |  日期 | 3 | `YYYY-MM-DD` | `1000-01-01` | `9999-12-31`
`TIME` | 时分秒 | 3 | HH:MM:SS | `-838:59:59` | `838:59:59`
`DATETIME` | DATE 和 TIME的组合 | 8 | `YYYY-MM-DD HH:MM:SS` | `1000-01-01 00:00:00` | `9999-12-31 23:59:59`
`TIMESTAMP` | 时间戳 | 4 | 同 `DATETIME` | `1970-01-01 00:00:00 UTC` | `2038-01-19 03:14:07 UTC`
`YEAR` | 年 | 1 | `YYYY | YY(不推荐)` | YY 格式是 `70` (1970年), YYYY 格式是 `1901`| YY 格式是 `69` (2069年), YYYY 格式是 `2155`

`TIMESTAMP` 与 `DATETIME` 除了存储字节和支持的范围不同外，还有一个最大的区别就是: `DATETIME` 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关;而 `TIMESTAMP` 值的存储是以 UTC (世界标准时间)格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。查询时，不同时区显示的时间值是不同的。

## 二进制数据类型

二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等。

类型 | 说明
-- | --
`BIT(M)` | 位字段类型，大约(M+7)/8字节
`BINARY(M)` | 固定长度二进制字符串，M字节
`VARBINARY(M)` | 可变长度二进制字符串，M+1字节
`TINYBLOB` | 非常小的 BLOB, L+1 字节，在此 L<2^8, 最大长度为255 (2**8-1) B
`BLOB` | Blob, L+2 字节，在此L<2^16， 最大长度为65535 (2**16-1) B
`MEDIUMBLOB` | 中等大小 Blob, L+3字节，在此L<2^24， 最大长度为16777215 (2**24-1) B
`LONGBLOB` | 大的 Blob, L+4字节,在此L<2^32，最大长度为4294967295 (2**32 -1) B或4GB

虽然使用 BLOB 或者 TEXT 可以存储大容量的数据，但是对这些字段的处理会降低数据库的性能。如果并非必要，可以选择只存储文件路径。
